# coding: utf-8

"""
    ibl-data-manager

    API for iblai

    The version of the OpenAPI document: 3.54.3-ai-plus
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ProgramLicenseUpdateDetail(BaseModel):
    """
    Request serializer for ProgramLicenseUpdateView POST endpoint.  This serializer validates the request data for updating an existing program license. Either license_id or external_id must be provided to identify the license to update.  Fields:     license_id: The ID of the license to update (required if external_id not provided)     external_id: External identifier of the license to update (required if license_id not provided)     name: Updated display name for the license     count: Updated number of seats purchased     started: Updated date when license should begin     expired: Updated date when license should expire     active: Updated active status     metadata: Updated additional license metadata     enrollment_config: Updated enrollment configuration     source: Updated source identifier     transaction_id: Transaction identifier for tracking     change_type: Type of change being made (default: \"update\")  Notes:     - Cannot update the platform or program associated with a license     - A license history record is automatically created for each update     - If count is reduced, it must not be less than the number of active assignments     - Setting active=false will not deactivate existing assignments
    """ # noqa: E501
    license_id: Optional[StrictInt] = Field(default=None, description="The ID of the license to update (required if external_id not provided)")
    external_id: Optional[StrictStr] = Field(default=None, description="External identifier of the license to update (required if license_id not provided)")
    name: Optional[StrictStr] = Field(default=None, description="Updated display name for the license")
    count: Optional[StrictInt] = Field(default=None, description="Updated number of seats purchased")
    started: Optional[datetime] = Field(default=None, description="Updated date when license should begin")
    expired: Optional[datetime] = Field(default=None, description="Updated date when license should expire")
    active: Optional[StrictBool] = Field(default=None, description="Updated active status")
    metadata: Optional[Dict[str, Any]] = Field(default=None, description="Updated additional license metadata")
    enrollment_config: Optional[Dict[str, Any]] = Field(default=None, description="Updated enrollment configuration")
    source: Optional[StrictStr] = Field(default=None, description="Updated source identifier")
    transaction_id: Optional[StrictStr] = Field(default=None, description="Transaction identifier for tracking")
    change_type: Optional[StrictStr] = Field(default='update', description="Type of change being made")
    __properties: ClassVar[List[str]] = ["license_id", "external_id", "name", "count", "started", "expired", "active", "metadata", "enrollment_config", "source", "transaction_id", "change_type"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ProgramLicenseUpdateDetail from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if expired (nullable) is None
        # and model_fields_set contains the field
        if self.expired is None and "expired" in self.model_fields_set:
            _dict['expired'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ProgramLicenseUpdateDetail from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "license_id": obj.get("license_id"),
            "external_id": obj.get("external_id"),
            "name": obj.get("name"),
            "count": obj.get("count"),
            "started": obj.get("started"),
            "expired": obj.get("expired"),
            "active": obj.get("active"),
            "metadata": obj.get("metadata"),
            "enrollment_config": obj.get("enrollment_config"),
            "source": obj.get("source"),
            "transaction_id": obj.get("transaction_id"),
            "change_type": obj.get("change_type") if obj.get("change_type") is not None else 'update'
        })
        return _obj


